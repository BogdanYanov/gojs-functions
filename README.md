# gojs-functions

Мы можем вызвать функцию не в данный момент, а позже, через заданный интервал времени. Это называется «планирование вызова».

Для этого в JS существуют два метода:  
  
+ ```setTimeout``` позволяет вызвать функцию один раз через определённый интервал времени.
+ ```setInterval``` позволяет вызывать функцию регулярно, повторяя вызов через определённый интервал времени.  
  
Эти методы не являются частью спецификации JavaScript. Но большинство сред выполнения JS-кода имеют внутренний планировщик и предоставляют доступ к этим методам. В частности, они поддерживаются во всех браузерах и Node.js.

В языке Go для их реализации можно воспользоваться пакетом ```time``` и **конкурентным программированием**.

Для ```SetInterval()``` в пакете ```time``` представлен метод ```NewTicker(d Duration)```. Он возвращает канал, который каждый раз, как наступает время ```d```, пишет в этот канал значение ```Time```.  
  
Значит для того, чтобы реализовать данную функцию, мы просто создаем объект ```Ticker``` и каждый раз, когда он будет писать в канал, мы будем выполнять функцию в запущенной горутине.  
Но теперь функция будет выполняться вечно. Чтобы это исправить, мы будем методом ```SetInterval()``` возвращать канал, который будет считаться остановкой выполнения функции, если в него что-то записать. 

Для ```SetTimeout()``` мы воспользуемся методом ```NewTimer(d Duration)```. Принцип работы метода точно такой же, как и у ```NewTicker()``` но событие отправки значения времени в канал одиночное, т.е. выполняется всего один раз.  

```SetTimeout()``` также возвращает канал, для остановки выполнения функции.

Также добавлен метод ```ClearTimer(clear chan struct{})``` который отправляет значение остановки, в переданный ему канал.

Так, как горутины могут не успеть завершиться до окончания потока ```main``` был добавлен в каждую из функций параметр ```sync.WaitGroup``` чтобы главная горутина дожидалась выполнения этих функций.
